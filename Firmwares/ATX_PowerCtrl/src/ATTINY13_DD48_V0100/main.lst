
AVRASM ver. 1.52  main.asm Fri Aug 03 10:26:03 2012


         ;----------------------------------------------------------------------------------------------------------------------------
         ; автор: Тарасов М.Н.
         ; main.asm  - модуль функций контроллера,  2012г.
         ; описание: программа управления питанием ATX блока питания компьютера ZXM-Phoenix 1024kb rev05 
         ; Тип микроконтроллера: ATTINY13
         ; Частота кварцевого резонатора : 4.800000 MHz
         ; Модель памяти : Small
         ; Версия: v1.00  - июнь 2012г.
         ;----------------------------------------------------------------------------------------------------------------------------
         ; Описание выводов микроконтроллера:
         ; PB0 - не используется
         ; PB1 - выход управления сигналом RESET компьютера
         ; PB2 - вход кнопки питания
         ; PB3 - выход управления сигналом POWER ON блока питания
         ; PB4 - выход управления светодиодом ИНДИКАТОР ПИТАНИЯ 
         ; PB5 - вход датчика напряжения POWER GOOD от блока питания
         ;----------------------------------------------------------------------------------------------------------------------------
         ; Алгоритм работы:
         ;
         ; 1. Компьютер не включен. С блока питания ATX приходит напряжение +5SB питания дежурного режима.
         ;    Действия: 
         ;	      a) При первоначальном появлении напряжения питания дежурного режима - инициализация внутренних ресурсов контроллера.
         ;	      б) Установить сигнал RESET в активное состояние лог. "0", светодиодом ИНДИКАТОР ПИТАНИЯ входим в режим мерцания,
         ;		 на выход POWER ON установим напряжение лог. "0".
         ;	      в) Основной цикл - опрос датчика напряжения POWER GOOD и мерцание светодиодом ИНДИКАТОР ПИТАНИЯ с переодичнстью 1 сек.
         ;	         опрос состояния кнопки питания.
         ;	      г) При при нажатии кнопки питания включаем блок питания путем подачи лог. "1" на выход POWER ON.
         ;	      д) При появлении активного сигнала на входе POWER GOOD, устанавливаем светодиод ИНДИКАТОР ПИТАНИЯ в режим постоянного свечения 
         ;                и возврата кнопки питания в ненажатое состояние переходим к режиму работы - Компьютер включен 
         ; 2. Компьютер включен. 
         ;    Действия:
         ;	      а) устанавливаем сигнал RESET в активное состояние лог. "1".
         ;	      б) Основной цикл - опрос датчика напряжения POWER GOOD, опрос состояния переключателя напряжения.
         ;	      в) При нажатии кнопки питания устанавливаем сигнал RESET в лог. "0". Если удержание кнопки питания длится более 5 сек
         ;	         происходит выключение питания путем подачи лог. "0" на выход POWER ON и затем входим в режим 1.б
         ;		 Если кнопка кнопка была в удержанном состоянии менее 5 сек, то устанавливаем сигнал RESET в лог. "1".  	 
         ;----------------------------------------------------------------------------------------------------------------------------
         ; Описание флагов состояния работы микроконтроллера: BYTE_STATUS_FLG
         ; 0 бит - 
         ; 1 бит - 
         ; 2 бит - 
         ; 5 бит - признак нажатия кнопки (0 - кнопку не нажимали, 1 - кнопку нажали)  
         ; 6 бит - признак индикации присутствия напряжения (0 - индикация отключена, 1 - индикация включена)
         ; 7 бит - признак режима ПИТАНИЕ КОМПЬЮТЕРА (0 - выключено, 1 - включено)
         ;----------------------------------------------------------------------------------------------------------------------------
          		        .DEF	BYTE_SAVE_AL    = R0 	;копия регистра AL
          		        .DEF	BYTE_SAVE_AH    = R1 	;копия регистра AH
          			.DEF	BYTE_SAVE_FLG   = R2    ;копия системного регистра
          			.DEF	BYTE_STATUS_FLG = R3    ;флаги состояния работы микроконтроллера
          			.DEF	BYTE_LED_COUNT  = R4    ;счетчик тиков для мерцания светодиода когда компьютер выключен
         
          			.DEF	BYTE_BUTTON_FLT = R10	;состояние кнопки - значение фильтра
          			.DEF	BYTE_BUTTON_RES = R11	;состояние кнопки - реальное значение
          			.DEF	MS_BUT_TIMERL   = R12   ;таймер фильтра кнопки
          			.DEF	MS_BUT_TIMERH   = R13
          			.DEF	MS_OFF_TIMERL   = R14   ;таймер на выключение компьютера
          			.DEF	MS_OFF_TIMERH   = R15
         
                                  .DEF	MS_CLOCKL      	= R20
          			.DEF	MS_CLOCKH      	= R21 
         
          			.DEF	DL = R24
          			.DEF	DH = R25
          			.DEF	CL = R26                ;регистр для передачи параметров в подпрограммы(младший байт)
          			.DEF	CH = R27                ;регистр для передачи параметров в подпрограммы(старший байт)
          			.DEF	BL = R28                ;регистр для передачи параметров в подпрограммы(младший байт)
          			.DEF	BH = R29                ;регистр для передачи параметров в подпрограммы(старший байт)
                                  .DEF	AL = R30		;аккумулятор low 
          			.DEF	AH = R31                ;            high
         			
          	            	.INCLUDE "ATTINY13.inc"
         ;------------------------------------------------------------------------------------------------------
         ;Описание: Все порты и внутренние регистры микроконтроллера  ATTINY13
         ;------------------------------------------------------------------------------------------------------
         ;			.DEVICE ATtiny13
         
          			.EQU ADCSRB =$03;
          			.EQU ADCL   =$04;
          			.EQU ADCH   =$05;
          			.EQU ADCW   =$04; 		// 16 bit access
          			.EQU ADCSRA =$06;
          			.EQU ADMUX  =$07;
          			.EQU ACSR   =$08;
          			.EQU DIDR0  =$14;
          			.EQU PCMSK  =$15;
          			.EQU PINB   =$16;
          			.EQU DDRB   =$17;
          			.EQU PORTB  =$18;
          			.EQU EECR   =$1C;
          			.EQU EEDR   =$1D;
          			.EQU EEAR   =$1E;
          			.EQU WDTCR  =$21;
          			.EQU CLKPR  =$26;
          			.EQU GTCCR  =$28;
          			.EQU OCR0B  =$29;
          			.EQU DWDR   =$2E;
          			.EQU TCCR0A =$2F;
          			.EQU OSCCAL =$31;
          			.EQU TCNT0  =$32;
          			.EQU TCCR0B =$33;
          			.EQU MCUSR  =$34;
          			.EQU MCUCR  =$35;
          			.EQU OCR0A  =$36;
          			.EQU SPMCSR =$37;
          			.EQU TIFR0  =$38;
          			.EQU TIMSK0 =$39;
          			.EQU GIFR   =$3A;
          			.EQU GIMSK  =$3B;
          			.EQU SPL    =$3D;
          			.EQU SREG   =$3F;
         
         
          			.EQU	TIMER_CLK = 181		;предделитель 256 - 75 CLK/256
         
          			.EQU	BUTTON_CNST_DLY  = 25	;фильтр в 100мс
          			.EQU	BUTTON_CNST_OFF  = 1250	;длительность 5 секунд
         
         
         ;-------------------------------------------------------------------------------------------------------
         ;Описание: Основная программа
         ;-------------------------------------------------------------------------------------------------------
           			.CSEG
          			.ORG	$0000
         
          START:     		
000000 c016      			RJMP 	RESET
000001 cffe      			RJMP 	START
000002 cffd      	      		RJMP 	START
000003 c09c      	      		RJMP 	TIM0_OVF
000004 cffb          	  		RJMP 	START
000005 cffa      	      		RJMP 	START
000006 cff9      	      		RJMP 	START
000007 cff8      	      		RJMP 	START
000008 cff7      	      		RJMP 	START
000009 cff6      	      		RJMP 	START
         		
          			.DB	"DD48 ver01.00 by Mick 2012"
00000a 4444
00000b 3834
00000c 7620
00000d 7265
00000e 3130
00000f 302e
000010 2030
000011 7962
000012 4d20
000013 6369
000014 206b
000015 3032
000016 3231
         
          RESET:			
000017 94f8      			CLI                             ;запрещаем прерывания
000018 27ee      			CLR  	AL
000019 bbec      			OUT  	EECR,AL
00001a bfe5      			OUT  	MCUCR,AL
00001b e9ef      			LDI  	AL,$9F
00001c bfed      			OUT  	SPL,AL
00001d d065      			RCALL	CPU_INI_HARD            ;настройка внутренних регистров микроконтроллера
00001e d070      			RCALL	CPU_INI_VARIABLE        ;очистим переменные
00001f 9478      			SEI                             ;разрешим прерывания
         
          MAIN_LOOP:
000020 fc37      			SBRC	BYTE_STATUS_FLG,7	;проверим работает ли компьютер (питание включено)
000021 c029      			RJMP	MAIN_POWER_ON		;установлен - отслеживаем состояние работающего компьютера
         ;-------------------------------------------------------------------------------------------------------
         ;Описание: Компьютер выключен
         ;-------------------------------------------------------------------------------------------------------
000022 9bb5      			SBIS	PINB,5			;проверим соcтояние входа POWER GOOD
000023 c012      			RJMP	MAIN_BUTTON_0		;если "0" то уходим на опрос кнопки
         			                                ;иначе - POWER GOOD активен
000024 fc36      			SBRC	BYTE_STATUS_FLG,6	;проверим зажигали при этом светодиод
000025 c003      			RJMP	MAIN_BUTTON_ON		;установлен - пропустим зажжение светодиода 
000026 9ac4      			SBI	PORTB,4			;зажжем светодиод индикатор питания
000027 e4e0      			LDI	AL,$40
000028 2a3e      			OR	BYTE_STATUS_FLG,AL	;установим признак что светодиод зажжен
          MAIN_BUTTON_ON:
000029 fe35      			SBRS	BYTE_STATUS_FLG,5	;проверим нажимали при этом кнопку
00002a c007      			RJMP	MAIN_COMPUTER_START	;сброшен - компьютер включили извне
         							;иначе - кнопку нажимали
00002b d040      			RCALL	CPU_BUTTON_PROCESSING	;отслеживаем изменение состояние кнопки
00002c 23ee      			TST	AL
00002d f391      			BREQ	MAIN_LOOP          	;состояние не менялось
00002e 20bb      			TST	BYTE_BUTTON_RES		;проверим состояние кнопки
00002f f011      			BREQ	MAIN_COMPUTER_START	;кнопку отжали - запускаем компьютер
000030 d063      			RCALL	CPU_CLEAR_STATUS
000031 cfee      			RJMP	MAIN_LOOP		;уходим в начало цикла
          MAIN_COMPUTER_START:
000032 e8e0      			LDI	AL,$80
000033 2e3e      			MOV	BYTE_STATUS_FLG,AL      ;установим признак КОМПЬЮТЕР ВКЛЮЧЕН
000034 9ac1      			SBI	PORTB,1			;освободим линию RESET
000035 cfea      			RJMP	MAIN_LOOP		;уходим в начало цикла
         
          MAIN_BUTTON_0:						;сигнал POWER GOOD неактивен
000036 d035      			RCALL	CPU_BUTTON_PROCESSING	;отслеживаем изменение состояние кнопки
000037 23ee      			TST	AL
000038 f049      			BREQ	MAIN_LED_FLASH          ;состояние не менялось - уходим на мерцание светодиода
000039 20bb      			TST	BYTE_BUTTON_RES		;проверим состояние кнопки
00003a f029      			BREQ	MAIN_BUTTON_CLEAR	;кнопку отжали раньше времени, сброс признаков
         							;иначе кнопку нажали
00003b e2e0      			LDI	AL,$20
00003c 2a3e      			OR	BYTE_STATUS_FLG,AL	;установим признак что кнопку нажали
00003d 98c4      			CBI	PORTB,4			;гасим светодиод питания
00003e 9ac3      			SBI	PORTB,3			;активируем POWER ON
00003f cfe0      			RJMP	MAIN_LOOP		;уходим в начало цикла
          MAIN_BUTTON_CLEAR:
000040 2433      			CLR	BYTE_STATUS_FLG		;очистим признаки запуска	
000041 98c3      			CBI	PORTB,3			;выключаем POWER ON
          MAIN_LED_FLASH:
000042 efea      			LDI	AL,250			;отслеживаем мерцание светодиода питания
000043 164e      			CP	BYTE_LED_COUNT,AL       ;проверим сколько тиков прошло
000044 f2d8      			BRLO	MAIN_LOOP		;меньше, в начало цикла
000045 b3e8      			IN	AL,PORTB		;прочитаем текущее состояние светодиода LED
000046 e1f0      			LDI	AH,$10
000047 27ef      			EOR	AL,AH	                ;изменим на противоположное
000048 bbe8      			OUT	PORTB,AL
000049 2444      			CLR	BYTE_LED_COUNT
00004a cfd5      			RJMP	MAIN_LOOP
         ;-------------------------------------------------------------------------------------------------------
         ;Описание: Компьютер включен
         ;-------------------------------------------------------------------------------------------------------
          MAIN_POWER_ON:						;компьютер включен
00004b 99b5      			SBIC	PINB,5			;проверим соcтояние входа POWER GOOD
00004c c002      			RJMP	MAIN_BUTTON_1		;если "1" то уходим на опрос кнопки
         			                                ;иначе - POWER GOOD не активен, компьютер выключен
00004d d046      			RCALL	CPU_CLEAR_STATUS
00004e cfd1      			RJMP	MAIN_LOOP		;уходим в начало цикла
         			
          MAIN_BUTTON_1:						;иначе опрашиваем кнопку
00004f d01c      			RCALL	CPU_BUTTON_PROCESSING	;отслеживаем изменение состояние кнопки
000050 23ee      			TST	AL
000051 f071      			BREQ	MAIN_BUTTON_2          	;состояние не менялось - посмотрим состояние кнопки
000052 20bb      			TST	BYTE_BUTTON_RES		;проверим состояние кнопки
000053 f031      			BREQ	MAIN_BUTTON_UNPRESS	;кнопку отжали - проверим нажимали ли ее до этого 
         							;кнопку нажали
000054 e2e0      			LDI	AL,$20
000055 2a3e      			OR	BYTE_STATUS_FLG,AL	;установим признак нажатия кнопки
000056 98c1      			CBI	PORTB,1			;активируем RESET
000057 2ee4      			MOV	MS_OFF_TIMERL,MS_CLOCKL ;загрузим таймер выключения
000058 2ef5      			MOV	MS_OFF_TIMERH,MS_CLOCKH
000059 cfc6      			RJMP	MAIN_LOOP		;в начало цикла
          MAIN_BUTTON_UNPRESS:					;кнопку отжали
00005a fe35      			SBRS	BYTE_STATUS_FLG,5	;проверим нажимали при этом кнопку
00005b cfc4      			RJMP	MAIN_LOOP		;сброшен - кнопку не нажимали, в начало цикла
00005c edef      			LDI	AL,$DF
00005d 223e      			AND	BYTE_STATUS_FLG,AL	;очистим признаки нажатия кнопки
00005e 9ac1      			SBI	PORTB,1			;освобождаем линию RESET
00005f cfc0      			RJMP	MAIN_LOOP			
          MAIN_BUTTON_2:						;проверим нажималась ли кнопка
000060 fe35      			SBRS	BYTE_STATUS_FLG,5	;проверим нажимали при этом кнопку
000061 cfbe      			RJMP	MAIN_LOOP		;сброшен - кнопку не нажимали, в начало цикла
         			                                ;кнопка нажата
000062 eec2      			LDI	BL,LOW (BUTTON_CNST_OFF) ;загрузим константу таймера выключения компьютера
000063 e0d4      			LDI	BH,HIGH (BUTTON_CNST_OFF)             		
000064 2dae      			MOV	CL,MS_OFF_TIMERL        ;загрузим значение таймера задержки
000065 2dbf      			MOV	CH,MS_OFF_TIMERH
000066 d032                 		RCALL	CPU_CHECK_DELAY         ;сравним с текущим значением таймера
000067 f018      			BRLO	MAIN_LOOP_0		;еще время есть - в начало цикла			
000068 edef      			LDI	AL,$DF
000069 223e      			AND	BYTE_STATUS_FLG,AL	;очистим признаки нажатия кнопки
00006a 98c3      			CBI	PORTB,3			;время вышло, отключаем POWER ON
          MAIN_LOOP_0:
00006b cfb4              		RJMP	MAIN_LOOP		;и ждем пока не исчезнет POWER GOOD
         ;-------------------------------------------------------------------------------------------------------
         ;Описание: Отслеживание значения кнопки
         ;Входные параметры: нет
         ;Выходные параметры: флаг CY =1 если произошло изменение
         ;-------------------------------------------------------------------------------------------------------
          CPU_BUTTON_PROCESSING:
00006c 27ee      			CLR	AL
00006d 9bb2      			SBIS	PINB,2			;кнопка не нажата
00006e 95e3      			INC	AL
00006f 15ea      			CP	AL,BYTE_BUTTON_FLT      ;состояния равны?
000070 f469      			BRNE	CPU_BUTTON_RELOAD	;нет - перезапишем состояние
000071 14ab      			CP	BYTE_BUTTON_FLT,BYTE_BUTTON_RES ;сравним с реальным значением
000072 f411      			BRNE	CPU_BUTTON_COMPARE	;не равны - проверим таймер
000073 27ee      			CLR	AL
000074 9508      			RET				;иначе выход	
          CPU_BUTTON_COMPARE:
000075 e1c9      			LDI	BL,LOW (BUTTON_CNST_DLY) ;загрузим константу таймера фильтра
000076 e0d0      			LDI	BH,HIGH (BUTTON_CNST_DLY)             		
000077 2dac      			MOV	CL,MS_BUT_TIMERL         ;загрузим значение таймера задержки
000078 2dbd      			MOV	CH,MS_BUT_TIMERH
000079 d01f                 		RCALL	CPU_CHECK_DELAY         ;сравним с текущим значением таймера
00007a f030      			BRLO	CPU_BUTTON_EXIT		;время еще не вышло
00007b 2cba      			MOV	BYTE_BUTTON_RES,BYTE_BUTTON_FLT ;установим новое значение кнопки
00007c e0e1      			LDI	AL,1
00007d 9508      			RET
          CPU_BUTTON_RELOAD:
00007e 2ec4      			MOV	MS_BUT_TIMERL,MS_CLOCKL  ;перегрузим таймер фильтра кнопки
00007f 2ed5      			MOV	MS_BUT_TIMERH,MS_CLOCKH
000080 2eae      			MOV	BYTE_BUTTON_FLT,AL	 ;запишем новое состояние
          CPU_BUTTON_EXIT:
000081 27ee      			CLR	AL
000082 9508      			RET
         ;-------------------------------------------------------------------------------------------------------
         ;Описание: Инициализация портов и регистров оборудования микроконтроллера
         ;Входные параметры: нет
         ;Выходные параметры: нет
         ;-------------------------------------------------------------------------------------------------------
          CPU_INI_HARD:	
000083 ece1      		        LDI	AL,$C1
000084 bbe8      			OUT	PORTB,AL		;очистим выходы
000085 e1ea      			LDI	AL,$1A
000086 bbe7      			OUT	DDRB,AL                 ;выходы 1,3,4 биты
000087 e0e2      			LDI	AL,$02			;очистка флагов таймеров
000088 bfe9      			OUT	TIMSK0,AL
000089 bfe8      			OUT	TIFR0,AL
00008a e0e4      			LDI	AL,$04			;предделитель CLK/256
00008b bfe3      			OUT	TCCR0B,AL
00008c ebe5      			LDI	AL,TIMER_CLK	        ;переполнение 256 - 25 = 231 (4мс)
00008d bfe2      			OUT	TCNT0,AL
00008e 9508      			RET
         ;-------------------------------------------------------------------------------------------------------
         ;Описание: Инициализация портов и регистров оборудования микроконтроллера
         ;Входные параметры: нет
         ;Выходные параметры: нет
         ;-------------------------------------------------------------------------------------------------------
          CPU_INI_VARIABLE:
00008f 2433      			CLR	BYTE_STATUS_FLG
000090 2444      			CLR	BYTE_LED_COUNT
000091 24aa      			CLR	BYTE_BUTTON_FLT
000092 24bb      			CLR	BYTE_BUTTON_RES
000093 9508      			RET
         ;-------------------------------------------------------------------------------------------------------
         ;Описание: Сброс состояний
         ;Входные параметры: нет 
         ;Выходные параметры: нет
         ;-------------------------------------------------------------------------------------------------------
          CPU_CLEAR_STATUS:
000094 2433      			CLR	BYTE_STATUS_FLG		;очистим признаки запуска	
000095 ece1      			LDI	AL,$C1  		;все выключаем
000096 bbe8      			OUT	PORTB,AL
000097 2444      			CLR	BYTE_LED_COUNT
000098 9508      			RET
         ;-------------------------------------------------------------------------------------------------------
         ;Описание: Подпрограмма проверки истечения задержки по времени
         ;Входные параметры:  BL,BH - пара регистров константа задержки
         ;		     CL,CH - пара регистров хранения задержки
         ;Выходные параметры: Флаг СY - установлен не равны 
         ;-------------------------------------------------------------------------------------------------------
          CPU_CHECK_DELAY:
000099 2f84      		  	MOV	DL,MS_CLOCKL
00009a 2f95      			MOV	DH,MS_CLOCKH
00009b 1b8a                              SUB	DL,CL
00009c 0b9b      			SBC	DH,CH
00009d 178c      			CP	DL,BL			;сравним старшие байты константы и величины задержки	
00009e 079d      			CPC	DH,BH                   ;сравним младшие байты константы и величины задержки	
00009f 9508      			RET			
         ;-------------------------------------------------------------------------------------------------------
         ;Описание: Обработка прерываний от систеного таймера каждые 4мс
         ;Входные параметры: нет 
         ;Выходные параметры: нет
         ;-------------------------------------------------------------------------------------------------------
          TIM0_OVF:		
0000a0 2e0e      			MOV	BYTE_SAVE_AL,AL         ;сохраним аккумулятор
0000a1 b7ef      			IN	AL,SREG
0000a2 2e2e      			MOV	BYTE_SAVE_FLG,AL
0000a3 b7e8      			IN	AL,TIFR0
0000a4 60e2      			ORI	AL,$02
0000a5 bfe8      			OUT	TIFR0,AL
0000a6 ebe5      			LDI	AL,TIMER_CLK	
0000a7 bfe2      			OUT	TCNT0,AL		;прерывание по таймеру происходит через 4мс 
0000a8 9543      			INC	MS_CLOCKL
0000a9 f409      	 		BRNE	TIM0_OVF_2
0000aa 9553      			INC	MS_CLOCKH
          TIM0_OVF_2:
0000ab 9443      			INC	BYTE_LED_COUNT
0000ac 2de2      		        MOV	AL,BYTE_SAVE_FLG       	; востановим флаг Z
0000ad bfef      			OUT	SREG,AL
0000ae 2de0      			MOV	AL,BYTE_SAVE_AL         ; востановим аккумулятор
0000af 9518              		RETI			

Assembly complete with no errors.
