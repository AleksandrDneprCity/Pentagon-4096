;----------------------------------------------------------------------------------------------------------------------------
; автор: Тарасов М.Н.
; main.asm  - модуль функций контроллера,  2012г.
; описание: программа управления питанием ATX блока питания компьютера ZXM-Phoenix 1024kb rev05 
; Тип микроконтроллера: ATTINY13
; Частота кварцевого резонатора : 4.800000 MHz
; Модель памяти : Small
; Версия: v1.00  - июнь 2012г.
;----------------------------------------------------------------------------------------------------------------------------
; Описание выводов микроконтроллера:
; PB0 - не используется
; PB1 - выход управления сигналом RESET компьютера
; PB2 - вход кнопки питания
; PB3 - выход управления сигналом POWER ON блока питания
; PB4 - выход управления светодиодом ИНДИКАТОР ПИТАНИЯ 
; PB5 - вход датчика напряжения POWER GOOD от блока питания
;----------------------------------------------------------------------------------------------------------------------------
; Алгоритм работы:
;
; 1. Компьютер не включен. С блока питания ATX приходит напряжение +5SB питания дежурного режима.
;    Действия: 
;	      a) При первоначальном появлении напряжения питания дежурного режима - инициализация внутренних ресурсов контроллера.
;	      б) Установить сигнал RESET в активное состояние лог. "0", светодиодом ИНДИКАТОР ПИТАНИЯ входим в режим мерцания,
;		 на выход POWER ON установим напряжение лог. "0".
;	      в) Основной цикл - опрос датчика напряжения POWER GOOD и мерцание светодиодом ИНДИКАТОР ПИТАНИЯ с переодичнстью 1 сек.
;	         опрос состояния кнопки питания.
;	      г) При при нажатии кнопки питания включаем блок питания путем подачи лог. "1" на выход POWER ON.
;	      д) При появлении активного сигнала на входе POWER GOOD, устанавливаем светодиод ИНДИКАТОР ПИТАНИЯ в режим постоянного свечения 
;                и возврата кнопки питания в ненажатое состояние переходим к режиму работы - Компьютер включен 
; 2. Компьютер включен. 
;    Действия:
;	      а) устанавливаем сигнал RESET в активное состояние лог. "1".
;	      б) Основной цикл - опрос датчика напряжения POWER GOOD, опрос состояния переключателя напряжения.
;	      в) При нажатии кнопки питания устанавливаем сигнал RESET в лог. "0". Если удержание кнопки питания длится более 5 сек
;	         происходит выключение питания путем подачи лог. "0" на выход POWER ON и затем входим в режим 1.б
;		 Если кнопка кнопка была в удержанном состоянии менее 5 сек, то устанавливаем сигнал RESET в лог. "1".  	 
;----------------------------------------------------------------------------------------------------------------------------
; Описание флагов состояния работы микроконтроллера: BYTE_STATUS_FLG
; 0 бит - 
; 1 бит - 
; 2 бит - 
; 5 бит - признак нажатия кнопки (0 - кнопку не нажимали, 1 - кнопку нажали)  
; 6 бит - признак индикации присутствия напряжения (0 - индикация отключена, 1 - индикация включена)
; 7 бит - признак режима ПИТАНИЕ КОМПЬЮТЕРА (0 - выключено, 1 - включено)
;----------------------------------------------------------------------------------------------------------------------------
		        .DEF	BYTE_SAVE_AL    = R0 	;копия регистра AL
		        .DEF	BYTE_SAVE_AH    = R1 	;копия регистра AH
			.DEF	BYTE_SAVE_FLG   = R2    ;копия системного регистра
			.DEF	BYTE_STATUS_FLG = R3    ;флаги состояния работы микроконтроллера
			.DEF	BYTE_LED_COUNT  = R4    ;счетчик тиков для мерцания светодиода когда компьютер выключен

			.DEF	BYTE_BUTTON_FLT = R10	;состояние кнопки - значение фильтра
			.DEF	BYTE_BUTTON_RES = R11	;состояние кнопки - реальное значение
			.DEF	MS_BUT_TIMERL   = R12   ;таймер фильтра кнопки
			.DEF	MS_BUT_TIMERH   = R13
			.DEF	MS_OFF_TIMERL   = R14   ;таймер на выключение компьютера
			.DEF	MS_OFF_TIMERH   = R15

                        .DEF	MS_CLOCKL      	= R20
			.DEF	MS_CLOCKH      	= R21 

			.DEF	DL = R24
			.DEF	DH = R25
			.DEF	CL = R26                ;регистр для передачи параметров в подпрограммы(младший байт)
			.DEF	CH = R27                ;регистр для передачи параметров в подпрограммы(старший байт)
			.DEF	BL = R28                ;регистр для передачи параметров в подпрограммы(младший байт)
			.DEF	BH = R29                ;регистр для передачи параметров в подпрограммы(старший байт)
                        .DEF	AL = R30		;аккумулятор low 
			.DEF	AH = R31                ;            high
			
	            	.INCLUDE "ATTINY13.inc"

			.EQU	TIMER_CLK = 181		;предделитель 256 - 75 CLK/256

			.EQU	BUTTON_CNST_DLY  = 25	;фильтр в 100мс
			.EQU	BUTTON_CNST_OFF  = 1250	;длительность 5 секунд


;-------------------------------------------------------------------------------------------------------
;Описание: Основная программа
;-------------------------------------------------------------------------------------------------------
 			.CSEG
			.ORG	$0000

START:     		
			RJMP 	RESET
			RJMP 	START
	      		RJMP 	START
	      		RJMP 	TIM0_OVF
    	  		RJMP 	START
	      		RJMP 	START
	      		RJMP 	START
	      		RJMP 	START
	      		RJMP 	START
	      		RJMP 	START
		
			.DB	"DD48 ver01.00 by Mick 2012"

RESET:			
			CLI                             ;запрещаем прерывания
			CLR  	AL
			OUT  	EECR,AL
			OUT  	MCUCR,AL
			LDI  	AL,$9F
			OUT  	SPL,AL
			RCALL	CPU_INI_HARD            ;настройка внутренних регистров микроконтроллера
			RCALL	CPU_INI_VARIABLE        ;очистим переменные
			SEI                             ;разрешим прерывания

MAIN_LOOP:
			SBRC	BYTE_STATUS_FLG,7	;проверим работает ли компьютер (питание включено)
			RJMP	MAIN_POWER_ON		;установлен - отслеживаем состояние работающего компьютера
;-------------------------------------------------------------------------------------------------------
;Описание: Компьютер выключен
;-------------------------------------------------------------------------------------------------------
			SBIS	PINB,5			;проверим соcтояние входа POWER GOOD
			RJMP	MAIN_BUTTON_0		;если "0" то уходим на опрос кнопки
			                                ;иначе - POWER GOOD активен
			SBRC	BYTE_STATUS_FLG,6	;проверим зажигали при этом светодиод
			RJMP	MAIN_BUTTON_ON		;установлен - пропустим зажжение светодиода 
			SBI	PORTB,4			;зажжем светодиод индикатор питания
			LDI	AL,$40
			OR	BYTE_STATUS_FLG,AL	;установим признак что светодиод зажжен
MAIN_BUTTON_ON:
			SBRS	BYTE_STATUS_FLG,5	;проверим нажимали при этом кнопку
			RJMP	MAIN_COMPUTER_START	;сброшен - компьютер включили извне
							;иначе - кнопку нажимали
			RCALL	CPU_BUTTON_PROCESSING	;отслеживаем изменение состояние кнопки
			TST	AL
			BREQ	MAIN_LOOP          	;состояние не менялось
			TST	BYTE_BUTTON_RES		;проверим состояние кнопки
			BREQ	MAIN_COMPUTER_START	;кнопку отжали - запускаем компьютер
			RCALL	CPU_CLEAR_STATUS
			RJMP	MAIN_LOOP		;уходим в начало цикла
MAIN_COMPUTER_START:
			LDI	AL,$80
			MOV	BYTE_STATUS_FLG,AL      ;установим признак КОМПЬЮТЕР ВКЛЮЧЕН
			SBI	PORTB,1			;освободим линию RESET
			RJMP	MAIN_LOOP		;уходим в начало цикла

MAIN_BUTTON_0:						;сигнал POWER GOOD неактивен
			RCALL	CPU_BUTTON_PROCESSING	;отслеживаем изменение состояние кнопки
			TST	AL
			BREQ	MAIN_LED_FLASH          ;состояние не менялось - уходим на мерцание светодиода
			TST	BYTE_BUTTON_RES		;проверим состояние кнопки
			BREQ	MAIN_BUTTON_CLEAR	;кнопку отжали раньше времени, сброс признаков
							;иначе кнопку нажали
			LDI	AL,$20
			OR	BYTE_STATUS_FLG,AL	;установим признак что кнопку нажали
			CBI	PORTB,4			;гасим светодиод питания
			SBI	PORTB,3			;активируем POWER ON
			RJMP	MAIN_LOOP		;уходим в начало цикла
MAIN_BUTTON_CLEAR:
			CLR	BYTE_STATUS_FLG		;очистим признаки запуска	
			CBI	PORTB,3			;выключаем POWER ON
MAIN_LED_FLASH:
			LDI	AL,250			;отслеживаем мерцание светодиода питания
			CP	BYTE_LED_COUNT,AL       ;проверим сколько тиков прошло
			BRLO	MAIN_LOOP		;меньше, в начало цикла
			IN	AL,PORTB		;прочитаем текущее состояние светодиода LED
			LDI	AH,$10
			EOR	AL,AH	                ;изменим на противоположное
			OUT	PORTB,AL
			CLR	BYTE_LED_COUNT
			RJMP	MAIN_LOOP
;-------------------------------------------------------------------------------------------------------
;Описание: Компьютер включен
;-------------------------------------------------------------------------------------------------------
MAIN_POWER_ON:						;компьютер включен
			SBIC	PINB,5			;проверим соcтояние входа POWER GOOD
			RJMP	MAIN_BUTTON_1		;если "1" то уходим на опрос кнопки
			                                ;иначе - POWER GOOD не активен, компьютер выключен
			RCALL	CPU_CLEAR_STATUS
			RJMP	MAIN_LOOP		;уходим в начало цикла
			
MAIN_BUTTON_1:						;иначе опрашиваем кнопку
			RCALL	CPU_BUTTON_PROCESSING	;отслеживаем изменение состояние кнопки
			TST	AL
			BREQ	MAIN_BUTTON_2          	;состояние не менялось - посмотрим состояние кнопки
			TST	BYTE_BUTTON_RES		;проверим состояние кнопки
			BREQ	MAIN_BUTTON_UNPRESS	;кнопку отжали - проверим нажимали ли ее до этого 
							;кнопку нажали
			LDI	AL,$20
			OR	BYTE_STATUS_FLG,AL	;установим признак нажатия кнопки
			CBI	PORTB,1			;активируем RESET
			MOV	MS_OFF_TIMERL,MS_CLOCKL ;загрузим таймер выключения
			MOV	MS_OFF_TIMERH,MS_CLOCKH
			RJMP	MAIN_LOOP		;в начало цикла
MAIN_BUTTON_UNPRESS:					;кнопку отжали
			SBRS	BYTE_STATUS_FLG,5	;проверим нажимали при этом кнопку
			RJMP	MAIN_LOOP		;сброшен - кнопку не нажимали, в начало цикла
			LDI	AL,$DF
			AND	BYTE_STATUS_FLG,AL	;очистим признаки нажатия кнопки
			SBI	PORTB,1			;освобождаем линию RESET
			RJMP	MAIN_LOOP			
MAIN_BUTTON_2:						;проверим нажималась ли кнопка
			SBRS	BYTE_STATUS_FLG,5	;проверим нажимали при этом кнопку
			RJMP	MAIN_LOOP		;сброшен - кнопку не нажимали, в начало цикла
			                                ;кнопка нажата
			LDI	BL,LOW (BUTTON_CNST_OFF) ;загрузим константу таймера выключения компьютера
			LDI	BH,HIGH (BUTTON_CNST_OFF)             		
			MOV	CL,MS_OFF_TIMERL        ;загрузим значение таймера задержки
			MOV	CH,MS_OFF_TIMERH
           		RCALL	CPU_CHECK_DELAY         ;сравним с текущим значением таймера
			BRLO	MAIN_LOOP_0		;еще время есть - в начало цикла			
			LDI	AL,$DF
			AND	BYTE_STATUS_FLG,AL	;очистим признаки нажатия кнопки
			CBI	PORTB,3			;время вышло, отключаем POWER ON
MAIN_LOOP_0:
        		RJMP	MAIN_LOOP		;и ждем пока не исчезнет POWER GOOD
;-------------------------------------------------------------------------------------------------------
;Описание: Отслеживание значения кнопки
;Входные параметры: нет
;Выходные параметры: флаг CY =1 если произошло изменение
;-------------------------------------------------------------------------------------------------------
CPU_BUTTON_PROCESSING:
			CLR	AL
			SBIS	PINB,2			;кнопка не нажата
			INC	AL
			CP	AL,BYTE_BUTTON_FLT      ;состояния равны?
			BRNE	CPU_BUTTON_RELOAD	;нет - перезапишем состояние
			CP	BYTE_BUTTON_FLT,BYTE_BUTTON_RES ;сравним с реальным значением
			BRNE	CPU_BUTTON_COMPARE	;не равны - проверим таймер
			CLR	AL
			RET				;иначе выход	
CPU_BUTTON_COMPARE:
			LDI	BL,LOW (BUTTON_CNST_DLY) ;загрузим константу таймера фильтра
			LDI	BH,HIGH (BUTTON_CNST_DLY)             		
			MOV	CL,MS_BUT_TIMERL         ;загрузим значение таймера задержки
			MOV	CH,MS_BUT_TIMERH
           		RCALL	CPU_CHECK_DELAY         ;сравним с текущим значением таймера
			BRLO	CPU_BUTTON_EXIT		;время еще не вышло
			MOV	BYTE_BUTTON_RES,BYTE_BUTTON_FLT ;установим новое значение кнопки
			LDI	AL,1
			RET
CPU_BUTTON_RELOAD:
			MOV	MS_BUT_TIMERL,MS_CLOCKL  ;перегрузим таймер фильтра кнопки
			MOV	MS_BUT_TIMERH,MS_CLOCKH
			MOV	BYTE_BUTTON_FLT,AL	 ;запишем новое состояние
CPU_BUTTON_EXIT:
			CLR	AL
			RET
;-------------------------------------------------------------------------------------------------------
;Описание: Инициализация портов и регистров оборудования микроконтроллера
;Входные параметры: нет
;Выходные параметры: нет
;-------------------------------------------------------------------------------------------------------
CPU_INI_HARD:	
		        LDI	AL,$C1
			OUT	PORTB,AL		;очистим выходы
			LDI	AL,$1A
			OUT	DDRB,AL                 ;выходы 1,3,4 биты
			LDI	AL,$02			;очистка флагов таймеров
			OUT	TIMSK0,AL
			OUT	TIFR0,AL
			LDI	AL,$04			;предделитель CLK/256
			OUT	TCCR0B,AL
			LDI	AL,TIMER_CLK	        ;переполнение 256 - 25 = 231 (4мс)
			OUT	TCNT0,AL
			RET
;-------------------------------------------------------------------------------------------------------
;Описание: Инициализация портов и регистров оборудования микроконтроллера
;Входные параметры: нет
;Выходные параметры: нет
;-------------------------------------------------------------------------------------------------------
CPU_INI_VARIABLE:
			CLR	BYTE_STATUS_FLG
			CLR	BYTE_LED_COUNT
			CLR	BYTE_BUTTON_FLT
			CLR	BYTE_BUTTON_RES
			RET
;-------------------------------------------------------------------------------------------------------
;Описание: Сброс состояний
;Входные параметры: нет 
;Выходные параметры: нет
;-------------------------------------------------------------------------------------------------------
CPU_CLEAR_STATUS:
			CLR	BYTE_STATUS_FLG		;очистим признаки запуска	
			LDI	AL,$C1  		;все выключаем
			OUT	PORTB,AL
			CLR	BYTE_LED_COUNT
			RET
;-------------------------------------------------------------------------------------------------------
;Описание: Подпрограмма проверки истечения задержки по времени
;Входные параметры:  BL,BH - пара регистров константа задержки
;		     CL,CH - пара регистров хранения задержки
;Выходные параметры: Флаг СY - установлен не равны 
;-------------------------------------------------------------------------------------------------------
CPU_CHECK_DELAY:
		  	MOV	DL,MS_CLOCKL
			MOV	DH,MS_CLOCKH
                        SUB	DL,CL
			SBC	DH,CH
			CP	DL,BL			;сравним старшие байты константы и величины задержки	
			CPC	DH,BH                   ;сравним младшие байты константы и величины задержки	
			RET			
;-------------------------------------------------------------------------------------------------------
;Описание: Обработка прерываний от систеного таймера каждые 4мс
;Входные параметры: нет 
;Выходные параметры: нет
;-------------------------------------------------------------------------------------------------------
TIM0_OVF:		
			MOV	BYTE_SAVE_AL,AL         ;сохраним аккумулятор
			IN	AL,SREG
			MOV	BYTE_SAVE_FLG,AL
			IN	AL,TIFR0
			ORI	AL,$02
			OUT	TIFR0,AL
			LDI	AL,TIMER_CLK	
			OUT	TCNT0,AL		;прерывание по таймеру происходит через 4мс 
			INC	MS_CLOCKL
	 		BRNE	TIM0_OVF_2
			INC	MS_CLOCKH
TIM0_OVF_2:
			INC	BYTE_LED_COUNT
		        MOV	AL,BYTE_SAVE_FLG       	; востановим флаг Z
			OUT	SREG,AL
			MOV	AL,BYTE_SAVE_AL         ; востановим аккумулятор
        		RETI			
